From a571996b146c1a8e6a0f9d41b46087112b86016c Mon Sep 17 00:00:00 2001
From: Paul Durrant <paul.durrant@citrix.com>
Date: Fri, 14 Nov 2014 15:07:22 +0000
Subject: [PATCH] Hardcode monitor config

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
diff --git a/hw/vga-xengt.c b/hw/vga-xengt.c
index 32379cd..e8ae651 100644
--- a/hw/vga-xengt.c
+++ b/hw/vga-xengt.c
@@ -67,12 +67,35 @@ typedef struct vgt_monitor_info {
     unsigned char edid[EDID_SIZE];
 }vgt_monitor_info_t;
 
+vgt_monitor_info_t monitor_config = {
+    .port_type = 1,
+    .port_is_dp = 1,
+    .port_override = 1,
+    /* Generic 1024x768 default EDID from linux/Documentation/EDID */
+    .edid = {0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
+	0x31, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x05, 0x16, 0x01, 0x03, 0x6d, 0x32, 0x1c, 0x78,
+	0xea, 0x5e, 0xc0, 0xa4, 0x59, 0x4a, 0x98, 0x25,
+	0x20, 0x50, 0x54, 0x00, 0x00, 0x00, 0xd1, 0xc0,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3a,
+	0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
+	0x45, 0x00, 0xf4, 0x19, 0x11, 0x00, 0x00, 0x1e,
+	0x00, 0x00, 0x00, 0xff, 0x00, 0x4c, 0x69, 0x6e,
+	0x75, 0x78, 0x20, 0x23, 0x30, 0x0a, 0x20, 0x20,
+	0x20, 0x20, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x3b,
+	0x3d, 0x42, 0x44, 0x0f, 0x00, 0x0a, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfc,
+	0x00, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x46,
+	0x48, 0x44, 0x0a, 0x20, 0x20, 0x20, 0x00, 0x05,
+    },
+};
+
 /* These are the default values */
 int vgt_low_gm_sz = 128; /* in MB */
 int vgt_high_gm_sz = 448; /* in MB */
 int vgt_fence_sz = 4;
 int vgt_primary = 1; /* -1 means "not specified */
-const char *vgt_monitor_config_file = NULL;
 
 int vgt_legacy_vga_ram_size;
 void vga_map(PCIDevice *pci_dev, int region_num,
@@ -118,245 +141,78 @@ static inline unsigned int port_info_to_type(unsigned char port_is_dp, int port)
     return ret;
 }
 
-static bool validate_monitor_configs(vgt_monitor_info_t *config)
-{
-    if (config->port_type >= MAX_PORTS) {
-        qemu_log("vGT: %s failed because the invalid port_type input: %d!\n",
-            __func__, config->port_type);
-        return false;
-    }
-    if (config->port_override >= MAX_PORTS) {
-        qemu_log("vGT: %s failed due to the invalid port_override input: %d!\n",
-            __func__, config->port_override);
-        return false;
-    }
-    if (config->edid[126] != 0) {
-        qemu_log("vGT: %s failed because there is extended block in EDID! "
-            "(EDID[126] is not zero)\n", __func__);
-        return false;
-    }
-
-    return true;
-}
-
-static void config_hvm_monitors(vgt_monitor_info_t *config)
+static void config_hvm_monitors(void)
 {
+    vgt_monitor_info_t *config = &monitor_config;
     const char *path_prefix = "/sys/kernel/vgt/vm";
     FILE *fp;
     char file_name[MAX_FILE_NAME_LENGTH];
     int ret;
+    char path[1024];
+    struct dirent *entry;
+    char connected[14];
+    int fd, sz;
+    int port;
 
     // override
     snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/port_override",
         path_prefix, xen_domid, 'A' + config->port_type);
+    printf("writing %s\n", file_name);
     if ((fp = fopen(file_name, "w")) == NULL) {
-        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
+        printf("vGT: %s failed to open file %s! errno = %d\n",
             __func__, file_name, errno);
         return;
     }
     fprintf(fp, "PORT_%c", 'A' + config->port_override);
     if (fclose(fp) != 0) {
-        qemu_log("vGT: %s failed to close file: errno = %d\n", __func__, errno);
+        printf("vGT: %s failed to close file: errno = %d\n", __func__, errno);
     }
 
     // type
     snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/type",
         path_prefix, xen_domid, 'A' + config->port_type);
+    printf("writing %s\n", file_name);
     if ((fp = fopen(file_name, "w")) == NULL) {
-        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
+        printf("vGT: %s failed to open file %s! errno = %d\n",
             __func__, file_name, errno);
         return;
     }
     fprintf(fp, "%d", port_info_to_type(config->port_is_dp, config->port_type));
     if (fclose(fp) != 0) {
-        qemu_log("vGT: %s failed to close file: errno = %d\n", __func__, errno);
+        printf("vGT: %s failed to close file: errno = %d\n", __func__, errno);
     }
 
     // edid
     snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/edid",
         path_prefix, xen_domid, 'A' + config->port_type);
+    printf("writing %s\n", file_name);
     if ((fp = fopen(file_name, "w")) == NULL) {
-        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
+        printf("vGT: %s failed to open file %s! errno = %d\n",
             __func__, file_name, errno);
         return;
     }
     ret = fwrite(config->edid, 1, EDID_SIZE, fp);
     if (ret != EDID_SIZE) {
-        qemu_log("vGT: %s failed to write EDID with returned size %d: "
+        printf("vGT: %s failed to write EDID with returned size %d: "
             "errno = %d\n", __func__, ret, errno);
     }
     if (fclose(fp) != 0) {
-        qemu_log("vGT: %s failed to close file: errno = %d\n", __func__, errno);
+        printf("vGT: %s failed to close file: errno = %d\n", __func__, errno);
     }
 
     // flush result to port structure
     snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/connection",
         path_prefix, xen_domid, 'A' + config->port_type);
+    printf("writing %s\n", file_name);
     if ((fp = fopen(file_name, "w")) == NULL) {
-        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
+        printf("vGT: %s failed to open file %s! errno = %d\n",
             __func__, file_name, errno);
         return;
     }
     fprintf(fp, "flush");
     if (fclose(fp) != 0) {
-        qemu_log("vGT: %s failed to close file: errno = %d\n", __func__, errno);
-    }
-}
-
-#define CTOI(chr) \
-    (chr >= '0' && chr <= '9' ? chr - '0' : \
-    (chr >= 'a' && chr <= 'f' ? chr - 'a' + 10 :\
-    (chr >= 'A' && chr <= 'F' ? chr - 'A' + 10 : -1)))
-
-static int get_byte_from_txt_file(FILE *file, const char *file_name)
-{
-    int i;
-    int val[2];
-
-    for (i = 0; i < 2; ++ i) {
-        do {
-            unsigned char buf;
-            if (fread(&buf, 1, 1, file) != 1) {
-                qemu_log("vGT: %s failed to get byte from text file %s with errno: %d!\n",
-                    __func__, file_name, errno);
-                return -1;
-            }
-
-            if (buf == '#') {
-                // ignore comments
-                int ret;
-                while (((ret = fread(&buf, 1, 1, file)) == 1) && (buf != '\n')) ;
-                if (ret != 1) {
-                    qemu_log("vGT: %s failed to proceed after comment string "
-                            "from text file %s with errno: %d!\n",
-                            __func__, file_name, errno);
-                    return -1;
-                }
-            }
-
-            val[i] = CTOI(buf);
-        } while (val[i] == -1);
-    }
-
-    return ((val[0] << 4) | val[1]);
-}
-
-static int get_config_header(unsigned char *buf, FILE *file, const char *file_name)
-{
-    int ret;
-    unsigned char chr;
-
-    if (fread(&chr, 1, 1, file) != 1) {
-        qemu_log("vGT: %s failed to get byte from text file %s with errno: %d!\n",
-            __func__, file_name, errno);
-        return -1;
-    }
-
-    if (chr == '#') {
-        // it is text format input.
-        while (((ret = fread(&chr, 1, 1, file)) == 1) && (chr != '\n')) ;
-        if (ret != 1) {
-            qemu_log("vGT: %s failed to proceed after comment string "
-                "from file %s with errno: %d!\n",
-                __func__, file_name, errno);
-            return -1;
-        }
-        ret = get_byte_from_txt_file(file, file_name);
-        buf[0] = 1;
-        buf[1] = (ret & 0xf);
-    } else {
-        if ((ret = fread(&buf[0], 1, 2, file)) != 2) {
-            qemu_log("vGT: %s failed to read file %s! "
-                "Expect to read %d bytes but only got %d bytes! errno: %d\n",
-                __func__, file_name, 2, ret, errno);
-            return -1;
-        }
-
-        if (buf[0] != 0) {
-            // it is text format input.
-            buf[1] -= '0';
-        }
+        printf("vGT: %s failed to close file: errno = %d\n", __func__, errno);
     }
-
-    return 0;
-}
-
-static void config_vgt_guest_monitors(void)
-{
-    FILE *monitor_config_f;
-    unsigned char buf[4];
-    vgt_monitor_info_t monitor_configs[MAX_INPUT_NUM];
-    bool text_mode;
-    int input_items;
-    int ret, i;
-
-    if (!vgt_monitor_config_file) {
-        return;
-    }
-
-    if ((monitor_config_f = fopen(vgt_monitor_config_file, "r")) == NULL) {
-        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
-            __func__, vgt_monitor_config_file, errno);
-        return;
-    }
-
-    if (get_config_header(buf, monitor_config_f, vgt_monitor_config_file) != 0) {
-        goto finish_config;
-    }
-
-    text_mode = !!buf[0];
-    input_items = buf[1];
-
-    if (input_items <= 0 || input_items > MAX_INPUT_NUM) {
-        qemu_log("vGT: %s, Out of range input of the number of items! "
-            "Should be [1 - 3] but input is %d\n", __func__, input_items);
-        goto finish_config;
-    }
-
-    if (text_mode) {
-        unsigned int total = sizeof(vgt_monitor_info_t) * input_items;
-        unsigned char *p = (unsigned char *)monitor_configs;
-        for (i = 0; i < total; ++i, ++p) {
-            unsigned int val = get_byte_from_txt_file(monitor_config_f,
-                vgt_monitor_config_file);
-            if (val == -1) {
-                break;
-            } else {
-                *p = val;
-            }
-        }
-        if (i < total) {
-            goto finish_config;
-        }
-    } else {
-        unsigned int total = sizeof(vgt_monitor_info_t) * input_items;
-        ret = fread(monitor_configs, sizeof(vgt_monitor_info_t), input_items,
-                    monitor_config_f);
-        if (ret != total) {
-            qemu_log("vGT: %s failed to read file %s! "
-                "Expect to read %d bytes but only got %d bytes! errno: %d\n",
-                 __func__, vgt_monitor_config_file, total, ret, errno);
-            goto finish_config;
-        }
-    }
-
-    for (i = 0; i < input_items; ++ i) {
-        if (validate_monitor_configs(&monitor_configs[i]) == false) {
-            qemu_log("vGT: %s the monitor config[%d] input from %s is not valid!\n",
-                __func__, i, vgt_monitor_config_file);
-            goto finish_config;
-        }
-    }
-    for (i = 0; i < input_items; ++ i) {
-        config_hvm_monitors(&monitor_configs[i]);
-    }
-
-finish_config:
-    if (fclose(monitor_config_f) != 0) {
-        qemu_log("vGT: %s failed to close file %s: errno = %d\n", __func__,
-            vgt_monitor_config_file, errno);
-    }
-    return;
 }
 
 /*
@@ -388,8 +244,8 @@ static void create_vgt_instance(void)
      * driver to create a vgt instanc for Domain domid with the required
      * parameters. NOTE: aperture_size and gm_size are in MB.
      */
-    if (!err && fprintf(vgt_file, "%d,%u,%u,%u,%u,%d\n", xen_domid,
-        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_legacy_vga_ram_size >> 20, vgt_primary) < 0) {
+    if (!err && fprintf(vgt_file, "%d,%u,%u,%u,%d\n", xen_domid,
+        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_primary) < 0) {
         err = errno;
     }
 
@@ -398,11 +254,11 @@ static void create_vgt_instance(void)
     }
 
     if (err) {
-        qemu_log("vGT: %s failed: errno=%d\n", __func__, err);
+        printf("vGT: %s failed: errno=%d\n", __func__, err);
         exit(-1);
     }
 
-    config_vgt_guest_monitors();
+    config_hvm_monitors();
 }
 
 /*
@@ -414,7 +270,7 @@ void destroy_vgt_instance(void)
     FILE *vgt_file;
     int err = 0;
 
-    qemu_log("vGT: %s: domid=%d\n", __func__, xen_domid);
+    printf("vGT: %s: domid=%d\n", __func__, xen_domid);
 
     if ((vgt_file = fopen(path, "w")) == NULL) {
         fprintf(stdout, "vGT: open %s failed\n", path);
@@ -433,7 +289,7 @@ void destroy_vgt_instance(void)
     }
 
     if (err) {
-        qemu_log("vGT: %s: failed: errno=%d\n", __func__, err);
+        printf("vGT: %s: failed: errno=%d\n", __func__, err);
         exit(-1);
     }
 }
diff --git a/vl.c b/vl.c
index d9ec47d..bac3a3a 100644
--- a/vl.c
+++ b/vl.c
@@ -3850,7 +3850,6 @@ enum {
     QEMU_OPTION_vgt_low_gm_sz,
     QEMU_OPTION_vgt_high_gm_sz,
     QEMU_OPTION_vgt_fence_sz,
-    QEMU_OPTION_vgt_monitor_config_file,
 
     /* Debug/Expert options: */
     QEMU_OPTION_serial,
@@ -4047,7 +4046,6 @@ static const QEMUOption qemu_options[] = {
     { "vgt_low_gm_sz", HAS_ARG, QEMU_OPTION_vgt_low_gm_sz },
     { "vgt_high_gm_sz", HAS_ARG, QEMU_OPTION_vgt_high_gm_sz },
     { "vgt_fence_sz", HAS_ARG, QEMU_OPTION_vgt_fence_sz },
-    { "vgt_monitor_config_file", HAS_ARG, QEMU_OPTION_vgt_monitor_config_file },
 
 #if defined(TARGET_ARM)
     { "old-param", 0, QEMU_OPTION_old_param },
@@ -5064,11 +5062,6 @@ geometry_error:
                     vgt_fence_sz = strtol(optarg,&ptr,10);
                 }
                 break;
-            case QEMU_OPTION_vgt_monitor_config_file:
-                {
-                    vgt_monitor_config_file = optarg;
-                }
-                break;
             case QEMU_OPTION_disable_opengl:
                 opengl_enabled = 0;
                 break;
