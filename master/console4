diff --git a/hw/vga-xengt.c b/hw/vga-xengt.c
index f40a815..f7b3286 100644
--- a/hw/vga-xengt.c
+++ b/hw/vga-xengt.c
@@ -267,8 +267,10 @@ done:
 }
 
 typedef struct xengt_fb {
-    void *base;
+    uint32_t start;
     size_t size;
+    uint32_t end;
+    void *base;
     struct drm_i915_gem_vgtbuffer gem_vgtbuffer;
 } xengt_fb_t;
 
@@ -278,6 +280,26 @@ static xengt_fb_t xengt_fb[XENGT_NR_FB];
 
 #define	P2ROUNDUP(_x, _a) -(-(_x) & -(_a))
 
+static void xengt_close_object(uint32_t handle)
+{
+    struct drm_gem_close gem_close;
+
+    memset(&gem_close, 0, sizeof (gem_close));
+    gem_close.handle = handle;
+
+    (void) drmIoctl(drm_fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
+}
+
+static void xengt_release_fb(xengt_fb_t *fb)
+{
+    qemu_log("vGT: %s %u\n", __func__, fb->gem_vgtbuffer.handle);
+
+    munmap(fb->base, fb->size);
+    xengt_close_object(fb->gem_vgtbuffer.handle);
+
+    memset(fb, 0, sizeof(*fb));
+}
+
 static xengt_fb_t *xengt_new_fb(struct drm_i915_gem_vgtbuffer *gem_vgtbuffer)
 {
     struct drm_i915_gem_mmap_gtt gem_mmap_gtt;
@@ -285,10 +307,28 @@ static xengt_fb_t *xengt_new_fb(struct drm_i915_gem_vgtbuffer *gem_vgtbuffer)
     int i;
     int rc;
 
+    /* Scan for overlaps first */
+    for (i = 0; i < XENGT_NR_FB; i++) {
+        uint32_t start, end;
+        size_t size;
+
+        fb = &xengt_fb[i];
+
+	start = gem_vgtbuffer->start;
+        size = (gem_vgtbuffer->size * TARGET_PAGE_SIZE);
+	end = start + size - 1;;
+	
+	if (fb->end <= start || fb->start >= end) /* no overlap */
+            continue;
+
+	xengt_release_fb(fb);
+    }
+
+    /* Now scan for empty slots */
     for (i = 0; i < XENGT_NR_FB; i++) {
         fb = &xengt_fb[i];
 
-        if (fb->gem_vgtbuffer.handle == 0)
+	if (fb->gem_vgtbuffer.handle == 0)
             goto empty_slot;
     }
 
@@ -302,7 +342,10 @@ empty_slot:
     if (rc < 0)
         goto fail2;
 
+    fb->start = gem_vgtbuffer->start;
     fb->size = gem_vgtbuffer->size * TARGET_PAGE_SIZE;
+    fb->end = fb->start + fb->size - 1;
+
     fb->base = mmap(NULL, fb->size, PROT_READ, MAP_SHARED,
 		    drm_fd, gem_mmap_gtt.offset);
     if (fb->base == MAP_FAILED)
@@ -344,16 +387,6 @@ static xengt_fb_t *xengt_lookup_fb(struct drm_i915_gem_vgtbuffer *gem_vgtbuffer)
     return NULL;
 }
 
-static void xengt_close_object(uint32_t handle)
-{
-    struct drm_gem_close gem_close;
-
-    memset(&gem_close, 0, sizeof (gem_close));
-    gem_close.handle = handle;
-
-    (void) drmIoctl(drm_fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
-}
-
 static xengt_fb_t *xengt_get_fb(void)
 {
     struct drm_i915_gem_vgtbuffer gem_vgtbuffer;
@@ -386,8 +419,6 @@ done:
 
 typedef struct xengt_surface {
     DisplayState *ds;
-    uint32_t     width;
-    uint32_t     height;
 } xengt_surface_t;
 
 static xengt_surface_t xengt_surface;
@@ -398,14 +429,14 @@ void xengt_draw_primary(DisplayState *ds)
     xengt_fb_t *fb;
     struct drm_i915_gem_vgtbuffer *gem_vgtbuffer;
     xengt_surface_t *surface = &xengt_surface;
+    uint8_t *src, *dst;
+    uint32_t line;
 
     if ((fb = xengt_get_fb()) == NULL)
         return;
 
     gem_vgtbuffer = &fb->gem_vgtbuffer;
 
-    qemu_log("vGT: %s %u\n", __func__, gem_vgtbuffer->handle);
-
     if (surface->ds != ds) {
         surface->ds = ds;
 
@@ -414,21 +445,21 @@ void xengt_draw_primary(DisplayState *ds)
         ds->surface = qemu_create_displaysurface(ds, gem_vgtbuffer->width,
                                                  gem_vgtbuffer->height);
         dpy_resize(ds);
-
-        surface->width = gem_vgtbuffer->width;
-        surface->height = gem_vgtbuffer->height;
     }
 
-    if (surface->width != gem_vgtbuffer->width ||
-        surface->height != gem_vgtbuffer->height) {
-        surface->width = gem_vgtbuffer->width;
-        surface->height = gem_vgtbuffer->height;
+    if (ds_get_width(ds) != gem_vgtbuffer->width ||
+        ds_get_height(ds) != gem_vgtbuffer->height)
+        qemu_console_resize(ds, gem_vgtbuffer->width, gem_vgtbuffer->height);
 
-        qemu_console_resize(ds, surface->width, surface->height);
+    dst = ds_get_data(ds);
+    src = fb->base;
+    for (line = 0; line < ds_get_height(ds); line++) {
+        memcpy(dst, src, ds_get_linesize(ds));
+        dst += ds_get_linesize(ds);
+        src += fb->gem_vgtbuffer.stride;
     }
 
-    memcpy(ds_get_data(ds), fb->base, fb->size);
-    dpy_update(ds, 0, 0, gem_vgtbuffer->width, gem_vgtbuffer->height);
+    dpy_update(ds, 0, 0, ds_get_width(ds), ds_get_height(ds));
 }
 
 /*
@@ -612,7 +643,6 @@ uint32_t vgt_bridge_pci_read(PCIDevice *pci_dev, uint32_t config_addr, int len)
     uint32_t val;
 
     val = pci_default_read_config(pci_dev, config_addr, len);
-    PT_LOG_DEV(pci_dev, "addr=%x len=%x val=%x\n", config_addr, len, val);
 
     return val;
 }
