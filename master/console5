diff --git a/hw/vga-xengt.c b/hw/vga-xengt.c
index f7b3286..fcb9bed 100644
--- a/hw/vga-xengt.c
+++ b/hw/vga-xengt.c
@@ -43,6 +43,7 @@ typedef uint32_t pci_addr_t;
 #include <libdrm/drm.h>
 #include <libdrm/i915_drm.h>
 #include <xf86drm.h>
+#include <sys/time.h>
 
 #if 0
 typedef struct vgt_vga_state {
@@ -267,14 +268,13 @@ done:
 }
 
 typedef struct xengt_fb {
-    uint32_t start;
-    size_t size;
-    uint32_t end;
+    uint64_t epoch;
     void *base;
+    size_t size;
     struct drm_i915_gem_vgtbuffer gem_vgtbuffer;
 } xengt_fb_t;
 
-#define XENGT_NR_FB 8
+#define XENGT_NR_FB 16
 
 static xengt_fb_t xengt_fb[XENGT_NR_FB];
 
@@ -290,9 +290,11 @@ static void xengt_close_object(uint32_t handle)
     (void) drmIoctl(drm_fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
 }
 
-static void xengt_release_fb(xengt_fb_t *fb)
+static void xengt_release_fb(unsigned int i)
 {
-    qemu_log("vGT: %s %u\n", __func__, fb->gem_vgtbuffer.handle);
+    xengt_fb_t *fb = &xengt_fb[i];
+
+    qemu_log("vGT: %s %u (epoch %lu)\n", __func__, i, fb->epoch);
 
     munmap(fb->base, fb->size);
     xengt_close_object(fb->gem_vgtbuffer.handle);
@@ -304,37 +306,30 @@ static xengt_fb_t *xengt_new_fb(struct drm_i915_gem_vgtbuffer *gem_vgtbuffer)
 {
     struct drm_i915_gem_mmap_gtt gem_mmap_gtt;
     xengt_fb_t *fb;
-    int i;
+    static uint64_t epoch = 1;
+    uint64_t oldest_epoch;
+    unsigned int i, oldest;
     int rc;
 
-    /* Scan for overlaps first */
-    for (i = 0; i < XENGT_NR_FB; i++) {
-        uint32_t start, end;
-        size_t size;
-
-        fb = &xengt_fb[i];
-
-	start = gem_vgtbuffer->start;
-        size = (gem_vgtbuffer->size * TARGET_PAGE_SIZE);
-	end = start + size - 1;;
-	
-	if (fb->end <= start || fb->start >= end) /* no overlap */
-            continue;
-
-	xengt_release_fb(fb);
-    }
+    oldest_epoch = epoch;
+    oldest = XENGT_NR_FB;
 
-    /* Now scan for empty slots */
     for (i = 0; i < XENGT_NR_FB; i++) {
         fb = &xengt_fb[i];
 
-	if (fb->gem_vgtbuffer.handle == 0)
-            goto empty_slot;
+        if (fb->epoch < oldest_epoch) {
+            oldest_epoch = fb->epoch;
+            oldest = i;
+        }
     }
+    assert(oldest < XENGT_NR_FB);
+
+    i = oldest;
+    fb = &xengt_fb[i];
 
-    goto fail1;
+    if (fb->gem_vgtbuffer.handle != 0)
+        xengt_release_fb(i);
 
-empty_slot:
     memset(&gem_mmap_gtt, 0, sizeof (gem_mmap_gtt));
     gem_mmap_gtt.handle = gem_vgtbuffer->handle;
 
@@ -342,18 +337,16 @@ empty_slot:
     if (rc < 0)
         goto fail2;
 
-    fb->start = gem_vgtbuffer->start;
+    fb->epoch = epoch++;
     fb->size = gem_vgtbuffer->size * TARGET_PAGE_SIZE;
-    fb->end = fb->start + fb->size - 1;
-
     fb->base = mmap(NULL, fb->size, PROT_READ, MAP_SHARED,
 		    drm_fd, gem_mmap_gtt.offset);
     if (fb->base == MAP_FAILED)
         goto fail3;
 
-    qemu_log("vGT: %s %u (%ux%ux%u)-> %p(+%p)\n", __func__,
-	     gem_vgtbuffer->handle, gem_vgtbuffer->width,
-	     gem_vgtbuffer->height, gem_vgtbuffer->bpp,
+    qemu_log("vGT: %s %u (epoch %lu) %ux%ux%u -> %p(+%p)\n", __func__,
+	     i, fb->epoch,
+             gem_vgtbuffer->width, gem_vgtbuffer->height, gem_vgtbuffer->bpp,
              fb->base, (void *)fb->size);
 
     fb->gem_vgtbuffer = *gem_vgtbuffer;
@@ -397,12 +390,22 @@ static xengt_fb_t *xengt_get_fb(void)
     gem_vgtbuffer.plane_id = I915_VGT_PLANE_PRIMARY;
     gem_vgtbuffer.vmid = xen_domid;	 
     gem_vgtbuffer.pipe_id = 0;
+    gem_vgtbuffer.flags = I915_VGTBUFFER_QUERY_ONLY;
   
     rc = drmIoctl(drm_fd, DRM_IOCTL_I915_GEM_VGTBUFFER, &gem_vgtbuffer);
     if (rc < 0)
         goto done;
 
-    if ((fb = xengt_lookup_fb(&gem_vgtbuffer)) != NULL) {
+    if ((fb = xengt_lookup_fb(&gem_vgtbuffer)) != NULL)
+        goto done;
+
+    gem_vgtbuffer.flags = 0;
+  
+    rc = drmIoctl(drm_fd, DRM_IOCTL_I915_GEM_VGTBUFFER, &gem_vgtbuffer);
+    if (rc < 0)
+        goto done;
+
+    if (unlikely((fb = xengt_lookup_fb(&gem_vgtbuffer)) != NULL)) {
         /* We don't need the new object so close it */
         xengt_close_object(gem_vgtbuffer.handle);
         goto done;
@@ -418,48 +421,80 @@ done:
 }
 
 typedef struct xengt_surface {
-    DisplayState *ds;
+    uint8_t *data;
+    struct timespec ts;
 } xengt_surface_t;
 
 static xengt_surface_t xengt_surface;
 
 void xengt_draw_primary(DisplayState *ds)
 {
-    uint32_t start;
+    xengt_surface_t *surface = &xengt_surface;
+    struct timespec ts;
+    uint64_t then, now, delta;
     xengt_fb_t *fb;
     struct drm_i915_gem_vgtbuffer *gem_vgtbuffer;
-    xengt_surface_t *surface = &xengt_surface;
     uint8_t *src, *dst;
-    uint32_t line;
+    int i;
+    uint32_t linesize;
+    int rc;
 
-    if ((fb = xengt_get_fb()) == NULL)
+    rc = clock_gettime(CLOCK_MONOTONIC, &ts);
+    if (rc < 0)
+        goto fail1;
+
+    /* calculate millisecond delta */
+    then = (surface->ts.tv_sec * 1000) + (surface->ts.tv_nsec / 1000000);
+    now = (ts.tv_sec * 1000) + (ts.tv_nsec / 1000000);
+    delta = now - then;
+
+    if (delta < 500)
         return;
 
+    surface->ts = ts;
+
+    if ((fb = xengt_get_fb()) == NULL)
+        goto fail2;
+
     gem_vgtbuffer = &fb->gem_vgtbuffer;
 
-    if (surface->ds != ds) {
-        surface->ds = ds;
+    if (ds_get_width(ds) != gem_vgtbuffer->width ||
+        ds_get_height(ds) != gem_vgtbuffer->height ||
+        ds_get_bits_per_pixel(ds) != gem_vgtbuffer->bpp) {
+	if (surface->data)
+            qemu_free(surface->data);
 
         qemu_free_displaysurface(ds);
 
-        ds->surface = qemu_create_displaysurface(ds, gem_vgtbuffer->width,
-                                                 gem_vgtbuffer->height);
+        linesize = gem_vgtbuffer->width * gem_vgtbuffer->bpp / 8;
+
+        surface->data = qemu_malloc(linesize * gem_vgtbuffer->height);
+        ds->surface = qemu_create_displaysurface_from(gem_vgtbuffer->width,
+                                                      gem_vgtbuffer->height,
+                                                      gem_vgtbuffer->bpp,
+                                                      linesize,
+                                                      surface->data);
         dpy_resize(ds);
     }
 
-    if (ds_get_width(ds) != gem_vgtbuffer->width ||
-        ds_get_height(ds) != gem_vgtbuffer->height)
-        qemu_console_resize(ds, gem_vgtbuffer->width, gem_vgtbuffer->height);
-
-    dst = ds_get_data(ds);
     src = fb->base;
-    for (line = 0; line < ds_get_height(ds); line++) {
-        memcpy(dst, src, ds_get_linesize(ds));
-        dst += ds_get_linesize(ds);
-        src += fb->gem_vgtbuffer.stride;
+    dst = ds_get_data(ds);
+    linesize = ds_get_linesize(ds);
+
+    for (i = 0; i < gem_vgtbuffer->height; i++) {
+        memcpy(dst, src, linesize);
+        dst += linesize;
+        src += gem_vgtbuffer->stride;
     }
 
-    dpy_update(ds, 0, 0, ds_get_width(ds), ds_get_height(ds));
+    dpy_update(ds, 0, 0, gem_vgtbuffer->width, gem_vgtbuffer->height);
+    return;
+
+fail2:
+    qemu_log("%s: fail2\n", __func__);
+
+fail1:
+    qemu_log("%s: fail1\n", __func__);
 }
 
 /*
