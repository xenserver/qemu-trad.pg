From a571996b146c1a8e6a0f9d41b46087112b86016c Mon Sep 17 00:00:00 2001
From: Paul Durrant <paul.durrant@citrix.com>
Date: Fri, 14 Nov 2014 15:07:22 +0000
Subject: [PATCH] Hardcode monitor config

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
diff --git a/Makefile.target b/Makefile.target
index 8c07dd9..2cf50b4 100644
--- a/Makefile.target
+++ b/Makefile.target
@@ -586,6 +586,7 @@ ifdef CONFIG_AUDIO
 OBJS+= $(SOUND_HW) pcspk.o
 CPPFLAGS += -DHAS_AUDIO -DHAS_AUDIO_CHOICE
 endif
+CPPFLAGS += -I/usr/include/libdrm
 OBJS+= ide.o pckbd.o ps2.o vga.o vgpu_fb.o dma.o
 OBJS+= fdc.o mc146818rtc.o serial.o i8259.o i8254.o pc.o
 OBJS+= cirrus_vga.o apic.o parallel.o acpi.o piix_pci.o
diff --git a/hw/vga-xengt.c b/hw/vga-xengt.c
index 5f08e8c..b4436b3 100644
--- a/hw/vga-xengt.c
+++ b/hw/vga-xengt.c
@@ -67,12 +67,35 @@ typedef struct vgt_monitor_info {
     unsigned char edid[EDID_SIZE];
 }vgt_monitor_info_t;
 
+vgt_monitor_info_t monitor_config = {
+    .port_type = 1,
+    .port_is_dp = 1,
+    .port_override = 1,
+    /* Generic 1024x768 default EDID from linux/Documentation/EDID */
+    .edid = {0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
+	0x31, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x05, 0x16, 0x01, 0x03, 0x6d, 0x32, 0x1c, 0x78,
+	0xea, 0x5e, 0xc0, 0xa4, 0x59, 0x4a, 0x98, 0x25,
+	0x20, 0x50, 0x54, 0x00, 0x00, 0x00, 0xd1, 0xc0,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3a,
+	0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
+	0x45, 0x00, 0xf4, 0x19, 0x11, 0x00, 0x00, 0x1e,
+	0x00, 0x00, 0x00, 0xff, 0x00, 0x4c, 0x69, 0x6e,
+	0x75, 0x78, 0x20, 0x23, 0x30, 0x0a, 0x20, 0x20,
+	0x20, 0x20, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x3b,
+	0x3d, 0x42, 0x44, 0x0f, 0x00, 0x0a, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfc,
+	0x00, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x46,
+	0x48, 0x44, 0x0a, 0x20, 0x20, 0x20, 0x00, 0x05,
+    },
+};
+
 /* These are the default values */
 int vgt_low_gm_sz = 128; /* in MB */
 int vgt_high_gm_sz = 448; /* in MB */
 int vgt_fence_sz = 4;
 int vgt_primary = 1; /* -1 means "not specified */
-const char *vgt_monitor_config_file = NULL;
 
 int vgt_legacy_vga_ram_size;
 void vga_map(PCIDevice *pci_dev, int region_num,
@@ -118,40 +141,26 @@ static inline unsigned int port_info_to_type(unsigned char port_is_dp, int port)
     return ret;
 }
 
-static bool validate_monitor_configs(vgt_monitor_info_t *config)
-{
-    if (config->port_type >= MAX_PORTS) {
-        qemu_log("vGT: %s failed because the invalid port_type input: %d!\n",
-            __func__, config->port_type);
-        return false;
-    }
-    if (config->port_override >= MAX_PORTS) {
-        qemu_log("vGT: %s failed due to the invalid port_override input: %d!\n",
-            __func__, config->port_override);
-        return false;
-    }
-    if (config->edid[126] != 0) {
-        qemu_log("vGT: %s failed because there is extended block in EDID! "
-            "(EDID[126] is not zero)\n", __func__);
-        return false;
-    }
-
-    return true;
-}
-
-static void config_hvm_monitors(vgt_monitor_info_t *config)
+static void config_hvm_monitors(void)
 {
+    vgt_monitor_info_t *config = &monitor_config;
     const char *path_prefix = "/sys/kernel/vgt/vm";
     FILE *fp;
     char file_name[MAX_FILE_NAME_LENGTH];
     int ret;
+    char path[1024];
+    struct dirent *entry;
+    char connected[14];
+    int fd, sz;
+    int port;
 
     // override
     snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/port_override",
         path_prefix, xen_domid, 'A' + config->port_type);
+    qemu_log("writing %s\n", file_name);
     if ((fp = fopen(file_name, "w")) == NULL) {
         qemu_log("vGT: %s failed to open file %s! errno = %d\n",
-            __func__, file_name, errno);
+                 __func__, file_name, errno);
         return;
     }
     fprintf(fp, "PORT_%c", 'A' + config->port_override);
@@ -162,9 +171,10 @@ static void config_hvm_monitors(vgt_monitor_info_t *config)
     // type
     snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/type",
         path_prefix, xen_domid, 'A' + config->port_type);
+    qemu_log("writing %s\n", file_name);
     if ((fp = fopen(file_name, "w")) == NULL) {
         qemu_log("vGT: %s failed to open file %s! errno = %d\n",
-            __func__, file_name, errno);
+                 __func__, file_name, errno);
         return;
     }
     fprintf(fp, "%d", port_info_to_type(config->port_is_dp, config->port_type));
@@ -175,15 +185,16 @@ static void config_hvm_monitors(vgt_monitor_info_t *config)
     // edid
     snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/edid",
         path_prefix, xen_domid, 'A' + config->port_type);
+    qemu_log("writing %s\n", file_name);
     if ((fp = fopen(file_name, "w")) == NULL) {
         qemu_log("vGT: %s failed to open file %s! errno = %d\n",
-            __func__, file_name, errno);
+                 __func__, file_name, errno);
         return;
     }
     ret = fwrite(config->edid, 1, EDID_SIZE, fp);
     if (ret != EDID_SIZE) {
         qemu_log("vGT: %s failed to write EDID with returned size %d: "
-            "errno = %d\n", __func__, ret, errno);
+                "errno = %d\n", __func__, ret, errno);
     }
     if (fclose(fp) != 0) {
         qemu_log("vGT: %s failed to close file: errno = %d\n", __func__, errno);
@@ -192,9 +203,10 @@ static void config_hvm_monitors(vgt_monitor_info_t *config)
     // flush result to port structure
     snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/connection",
         path_prefix, xen_domid, 'A' + config->port_type);
+    qemu_log("writing %s\n", file_name);
     if ((fp = fopen(file_name, "w")) == NULL) {
         qemu_log("vGT: %s failed to open file %s! errno = %d\n",
-            __func__, file_name, errno);
+                 __func__, file_name, errno);
         return;
     }
     fprintf(fp, "flush");
@@ -203,162 +215,6 @@ static void config_hvm_monitors(vgt_monitor_info_t *config)
     }
 }
 
-#define CTOI(chr) \
-    (chr >= '0' && chr <= '9' ? chr - '0' : \
-    (chr >= 'a' && chr <= 'f' ? chr - 'a' + 10 :\
-    (chr >= 'A' && chr <= 'F' ? chr - 'A' + 10 : -1)))
-
-static int get_byte_from_txt_file(FILE *file, const char *file_name)
-{
-    int i;
-    int val[2];
-
-    for (i = 0; i < 2; ++ i) {
-        do {
-            unsigned char buf;
-            if (fread(&buf, 1, 1, file) != 1) {
-                qemu_log("vGT: %s failed to get byte from text file %s with errno: %d!\n",
-                    __func__, file_name, errno);
-                return -1;
-            }
-
-            if (buf == '#') {
-                // ignore comments
-                int ret;
-                while (((ret = fread(&buf, 1, 1, file)) == 1) && (buf != '\n')) ;
-                if (ret != 1) {
-                    qemu_log("vGT: %s failed to proceed after comment string "
-                            "from text file %s with errno: %d!\n",
-                            __func__, file_name, errno);
-                    return -1;
-                }
-            }
-
-            val[i] = CTOI(buf);
-        } while (val[i] == -1);
-    }
-
-    return ((val[0] << 4) | val[1]);
-}
-
-static int get_config_header(unsigned char *buf, FILE *file, const char *file_name)
-{
-    int ret;
-    unsigned char chr;
-
-    if (fread(&chr, 1, 1, file) != 1) {
-        qemu_log("vGT: %s failed to get byte from text file %s with errno: %d!\n",
-            __func__, file_name, errno);
-        return -1;
-    }
-
-    if (chr == '#') {
-        // it is text format input.
-        while (((ret = fread(&chr, 1, 1, file)) == 1) && (chr != '\n')) ;
-        if (ret != 1) {
-            qemu_log("vGT: %s failed to proceed after comment string "
-                "from file %s with errno: %d!\n",
-                __func__, file_name, errno);
-            return -1;
-        }
-        ret = get_byte_from_txt_file(file, file_name);
-        buf[0] = 1;
-        buf[1] = (ret & 0xf);
-    } else {
-        if ((ret = fread(&buf[0], 1, 2, file)) != 2) {
-            qemu_log("vGT: %s failed to read file %s! "
-                "Expect to read %d bytes but only got %d bytes! errno: %d\n",
-                __func__, file_name, 2, ret, errno);
-            return -1;
-        }
-
-        if (buf[0] != 0) {
-            // it is text format input.
-            buf[1] -= '0';
-        }
-    }
-
-    return 0;
-}
-
-static void config_vgt_guest_monitors(void)
-{
-    FILE *monitor_config_f;
-    unsigned char buf[4];
-    vgt_monitor_info_t monitor_configs[MAX_INPUT_NUM];
-    bool text_mode;
-    int input_items;
-    int ret, i;
-
-    if (!vgt_monitor_config_file) {
-        return;
-    }
-
-    if ((monitor_config_f = fopen(vgt_monitor_config_file, "r")) == NULL) {
-        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
-            __func__, vgt_monitor_config_file, errno);
-        return;
-    }
-
-    if (get_config_header(buf, monitor_config_f, vgt_monitor_config_file) != 0) {
-        goto finish_config;
-    }
-
-    text_mode = !!buf[0];
-    input_items = buf[1];
-
-    if (input_items <= 0 || input_items > MAX_INPUT_NUM) {
-        qemu_log("vGT: %s, Out of range input of the number of items! "
-            "Should be [1 - 3] but input is %d\n", __func__, input_items);
-        goto finish_config;
-    }
-
-    if (text_mode) {
-        unsigned int total = sizeof(vgt_monitor_info_t) * input_items;
-        unsigned char *p = (unsigned char *)monitor_configs;
-        for (i = 0; i < total; ++i, ++p) {
-            unsigned int val = get_byte_from_txt_file(monitor_config_f,
-                vgt_monitor_config_file);
-            if (val == -1) {
-                break;
-            } else {
-                *p = val;
-            }
-        }
-        if (i < total) {
-            goto finish_config;
-        }
-    } else {
-        unsigned int total = sizeof(vgt_monitor_info_t) * input_items;
-        ret = fread(monitor_configs, sizeof(vgt_monitor_info_t), input_items,
-                    monitor_config_f);
-        if (ret != total) {
-            qemu_log("vGT: %s failed to read file %s! "
-                "Expect to read %d bytes but only got %d bytes! errno: %d\n",
-                 __func__, vgt_monitor_config_file, total, ret, errno);
-            goto finish_config;
-        }
-    }
-
-    for (i = 0; i < input_items; ++ i) {
-        if (validate_monitor_configs(&monitor_configs[i]) == false) {
-            qemu_log("vGT: %s the monitor config[%d] input from %s is not valid!\n",
-                __func__, i, vgt_monitor_config_file);
-            goto finish_config;
-        }
-    }
-    for (i = 0; i < input_items; ++ i) {
-        config_hvm_monitors(&monitor_configs[i]);
-    }
-
-finish_config:
-    if (fclose(monitor_config_f) != 0) {
-        qemu_log("vGT: %s failed to close file %s: errno = %d\n", __func__,
-            vgt_monitor_config_file, errno);
-    }
-    return;
-}
-
 /*
  *  Inform vGT driver to create a vGT instance
  */
@@ -388,8 +244,8 @@ static void create_vgt_instance(void)
      * driver to create a vgt instanc for Domain domid with the required
      * parameters. NOTE: aperture_size and gm_size are in MB.
      */
-    if (!err && fprintf(vgt_file, "%d,%u,%u,%u,%u,%d\n", xen_domid,
-        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_legacy_vga_ram_size >> 20, vgt_primary) < 0) {
+    if (!err && fprintf(vgt_file, "%d,%u,%u,%u,%d\n", xen_domid,
+        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_primary) < 0) {
         err = errno;
     }
 
@@ -402,7 +258,7 @@ static void create_vgt_instance(void)
         exit(-1);
     }
 
-    config_vgt_guest_monitors();
+    config_hvm_monitors();
 }
 
 /*
@@ -417,7 +273,7 @@ void destroy_vgt_instance(void)
     qemu_log("vGT: %s: domid=%d\n", __func__, xen_domid);
 
     if ((vgt_file = fopen(path, "w")) == NULL) {
-        fprintf(stdout, "vGT: open %s failed\n", path);
+        qemu_log("vGT: open %s failed\n", path);
         err = errno;
     }
 
@@ -482,7 +338,7 @@ static void vgt_bridge_pci_conf_init_from_host(PCIDevice *dev,
      * only for a single VM scenario.
     */
     if ( !(host_dev = pt_pci_get_dev(0, 0, 0))) {
-        fprintf(stderr, " Error, failed to get host PCI device\n");
+        qemu_log("Error, failed to get host PCI device\n");
     }
 
     *((u32*)(dev->config + addr)) = pt_pci_host_read(host_dev, addr, len);
@@ -517,13 +373,13 @@ static void vgt_vga_map(PCIDevice *pci_dev, int region_num,
 }
 void vgt_bridge_pci_conf_init(PCIDevice *pci_dev)
 {
-    printf("vgt_bridge_pci_conf_init\n");
-    printf("vendor id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x00));
+    qemu_log("vgt_bridge_pci_conf_init\n");
+    qemu_log("vendor id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x00));
     vgt_bridge_pci_conf_init_from_host(pci_dev, 0x00, 2); /* vendor id */
-    printf("vendor id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x00));
-    printf("device id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x02));
+    qemu_log("vendor id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x00));
+    qemu_log("device id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x02));
     vgt_bridge_pci_conf_init_from_host(pci_dev, 0x02, 2); /* device id */
-    printf("device id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x02));
+    qemu_log("device id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x02));
     vgt_bridge_pci_conf_init_from_host(pci_dev, 0x06, 2); /* status */
     vgt_bridge_pci_conf_init_from_host(pci_dev, 0x08, 2); /* revision id */
     vgt_bridge_pci_conf_init_from_host(pci_dev, 0x34, 1); /* capability */
@@ -577,7 +433,7 @@ void xengt_vga_init(PCIBus *pci_bus, ram_addr_t vga_ram_addr, int vga_ram_size)
     uint8_t  rid;
 
     if (!(host_dev = pt_pci_get_dev(0, 0, 0))) {
-        fprintf(stderr, " Error, failed to get host PCI device\n");
+        qemu_log("Error, failed to get host PCI device\n");
         return;
     }
 
@@ -585,7 +441,7 @@ void xengt_vga_init(PCIBus *pci_bus, ram_addr_t vga_ram_addr, int vga_ram_size)
     did = pt_pci_host_read(host_dev, PCI_DEVICE_ID, 2);
     rid = pt_pci_host_read(host_dev, PCI_REVISION, 1);
     if (vid != PCI_VENDOR_ID_INTEL) {
-        fprintf(stderr, " Error, vga-xengt is only supported on Intel GPUs\n");
+        qemu_log("Error, vga-xengt is only supported on Intel GPUs\n");
         return;
     }
 
@@ -595,20 +451,20 @@ void xengt_vga_init(PCIBus *pci_bus, ram_addr_t vga_ram_addr, int vga_ram_size)
                            PCI_ADDRESS_SPACE_MEM_PREFETCH, vgt_vga_map);
 
     /* Note I have not set the class code of the bridge! */
-    printf("Create xengt ISA bridge successfully\n");
+    qemu_log("Create xengt ISA bridge successfully\n");
     ret = pci_vga_init(pci_bus, PCI_DEVFN(0x2,0),
 			 phys_ram_base + vga_ram_addr,
                          vga_ram_addr, vga_ram_size, 0, 0);
 
     vgt_legacy_vga_ram_size = vga_ram_size;
     if (ret) {
-        fprintf(stderr, "Warning: vga-xengt not available\n");
+        qemu_log("Warning: vga-xengt not available\n");
         return;
     }
 
     create_vgt_instance();
     qemu_register_exit(vgt_cleanupfn2, NULL);
-    printf("Create xengt VGA successfully\n");
+    qemu_log("Create xengt VGA successfully\n");
     return;
 }
 /*
diff --git a/vl.c b/vl.c
index 82bf379..09cbe97 100644
--- a/vl.c
+++ b/vl.c
@@ -3884,7 +3884,6 @@ enum {
     QEMU_OPTION_vgt_low_gm_sz,
     QEMU_OPTION_vgt_high_gm_sz,
     QEMU_OPTION_vgt_fence_sz,
-    QEMU_OPTION_vgt_monitor_config_file,
 
     /* Debug/Expert options: */
     QEMU_OPTION_serial,
@@ -4077,7 +4076,6 @@ static const QEMUOption qemu_options[] = {
     { "vgt_low_gm_sz", HAS_ARG, QEMU_OPTION_vgt_low_gm_sz },
     { "vgt_high_gm_sz", HAS_ARG, QEMU_OPTION_vgt_high_gm_sz },
     { "vgt_fence_sz", HAS_ARG, QEMU_OPTION_vgt_fence_sz },
-    { "vgt_monitor_config_file", HAS_ARG, QEMU_OPTION_vgt_monitor_config_file },
 
 #if defined(TARGET_ARM)
     { "old-param", 0, QEMU_OPTION_old_param },
@@ -5074,11 +5072,6 @@ int main(int argc, char **argv, char **envp)
                     vgt_fence_sz = strtol(optarg,&ptr,10);
                 }
                 break;
-            case QEMU_OPTION_vgt_monitor_config_file:
-                {
-                    vgt_monitor_config_file = optarg;
-                }
-                break;
             case QEMU_OPTION_disable_opengl:
                 opengl_enabled = 0;
                 break;
